import { readFile, writeFile } from 'node:fs/promises';
import path from 'node:path';
import { fileURLToPath } from 'node:url';

const __dirname = path.dirname(fileURLToPath(import.meta.url));
const root = path.resolve(__dirname, '..');

const defaultConfigPath = path.join(root, 'config/game_rules.json');
const defaultTsPath = path.join(root, 'src/shared/constants.ts');
const defaultRsPath = path.join(root, 'rust/server/src/constants.rs');

const GENERATED_HEADER = '// @generated by scripts/generate-game-rules.mjs. DO NOT EDIT.';
const INT32_MAX = 2_147_483_647;
const UINT32_MAX = 4_294_967_295;
const SAFE_INT_MAX = Number.MAX_SAFE_INTEGER;

const toTsNumber = (value) => `${value}`;
const toRsFloat = (value) => {
  if (Number.isInteger(value)) {
    return `${value}.0`;
  }
  return `${value}`;
};

function assertCondition(condition, message) {
  if (!condition) {
    throw new Error(message);
  }
}

function assertNumber(value, fieldPath, opts = {}) {
  assertCondition(typeof value === 'number' && Number.isFinite(value), `${fieldPath} must be a finite number`);
  if (opts.integer) {
    assertCondition(Number.isInteger(value), `${fieldPath} must be an integer`);
    if (opts.safeInteger !== false) {
      assertCondition(Number.isSafeInteger(value), `${fieldPath} must be a safe integer`);
    }
  }
  if (opts.min !== undefined) {
    assertCondition(value >= opts.min, `${fieldPath} must be >= ${opts.min}`);
  }
  if (opts.max !== undefined) {
    assertCondition(value <= opts.max, `${fieldPath} must be <= ${opts.max}`);
  }
}

function assertObject(value, fieldPath) {
  assertCondition(value !== null && typeof value === 'object' && !Array.isArray(value), `${fieldPath} must be an object`);
}

function assertAscendingRows(rows, fieldPath, valueField, valueOptions = {}, thresholdOptions = {}) {
  assertCondition(Array.isArray(rows) && rows.length > 0, `${fieldPath} must be a non-empty array`);
  let previousThreshold = -Infinity;
  for (let index = 0; index < rows.length; index += 1) {
    const row = rows[index];
    const rowPath = `${fieldPath}[${index}]`;
    assertObject(row, rowPath);
    assertNumber(row.maxPlayers, `${rowPath}.maxPlayers`, { integer: true, min: 1, ...thresholdOptions });
    assertCondition(row.maxPlayers > previousThreshold, `${rowPath}.maxPlayers must be strictly ascending`);
    previousThreshold = row.maxPlayers;
    assertNumber(row[valueField], `${rowPath}.${valueField}`, { integer: true, min: 1, ...valueOptions });
  }
}

function assertCapturePressureRows(rows, fieldPath) {
  assertCondition(Array.isArray(rows) && rows.length > 0, `${fieldPath} must be a non-empty array`);
  let previousThreshold = -Infinity;
  for (let index = 0; index < rows.length; index += 1) {
    const row = rows[index];
    const rowPath = `${fieldPath}[${index}]`;
    assertObject(row, rowPath);
    assertNumber(row.maxCaptureRatio, `${rowPath}.maxCaptureRatio`, { min: 0, max: 1 });
    assertCondition(row.maxCaptureRatio > previousThreshold, `${rowPath}.maxCaptureRatio must be strictly ascending`);
    previousThreshold = row.maxCaptureRatio;
    assertNumber(row.graceMs, `${rowPath}.graceMs`, { integer: true, min: 1, max: SAFE_INT_MAX });
    assertNumber(row.regenMultiplier, `${rowPath}.regenMultiplier`, { min: 0 });
  }
}

export function validateConfig(config) {
  assertObject(config, 'config');

  assertNumber(config.tickRate, 'tickRate', { integer: true, min: 1, max: UINT32_MAX });
  assertNumber(config.sectorSize, 'sectorSize', { integer: true, min: 1, max: INT32_MAX });
  assertNumber(config.dotsForAwaken, 'dotsForAwaken', { integer: true, min: 1, max: INT32_MAX });
  assertNumber(config.maxAwakenStock, 'maxAwakenStock', { integer: true, min: 1, max: INT32_MAX });
  assertNumber(config.powerDurationMs, 'powerDurationMs', { integer: true, min: 1, max: SAFE_INT_MAX });
  assertNumber(config.awakenDurationMs, 'awakenDurationMs', { integer: true, min: 1, max: SAFE_INT_MAX });
  assertNumber(config.rescueTimeoutMs, 'rescueTimeoutMs', { integer: true, min: 1, max: SAFE_INT_MAX });
  assertNumber(config.powerPelletRespawnMs, 'powerPelletRespawnMs', { integer: true, min: 1, max: SAFE_INT_MAX });
  assertNumber(config.playerBaseSpeed, 'playerBaseSpeed', { min: 0 });
  assertNumber(config.playerCapturedSpeedMultiplier, 'playerCapturedSpeedMultiplier', { min: 0 });
  assertNumber(config.ghostBaseSpeed, 'ghostBaseSpeed', { min: 0 });
  assertNumber(config.powerAuraRadius, 'powerAuraRadius', { integer: true, min: 0, max: SAFE_INT_MAX });

  assertAscendingRows(
    config.mapSideByPlayers,
    'mapSideByPlayers',
    'value',
    { max: INT32_MAX },
    { max: SAFE_INT_MAX }
  );
  assertNumber(config.mapSideDefault, 'mapSideDefault', { integer: true, min: 1, max: INT32_MAX });

  assertAscendingRows(
    config.initialGhostCountByPlayers,
    'initialGhostCountByPlayers',
    'value',
    { max: SAFE_INT_MAX },
    { max: SAFE_INT_MAX }
  );
  assertNumber(config.initialGhostCountDefault, 'initialGhostCountDefault', { integer: true, min: 1, max: SAFE_INT_MAX });

  assertAscendingRows(
    config.timeLimitMsByPlayers,
    'timeLimitMsByPlayers',
    'value',
    { max: SAFE_INT_MAX },
    { max: SAFE_INT_MAX }
  );
  assertNumber(config.timeLimitMsDefault, 'timeLimitMsDefault', { integer: true, min: 1, max: SAFE_INT_MAX });

  assertObject(config.difficultyMultipliers, 'difficultyMultipliers');
  for (const level of ['casual', 'normal', 'hard', 'nightmare']) {
    const multiplier = config.difficultyMultipliers[level];
    assertObject(multiplier, `difficultyMultipliers.${level}`);
    assertNumber(multiplier.ghostSpeed, `difficultyMultipliers.${level}.ghostSpeed`, { min: 0 });
    assertNumber(multiplier.maintenance, `difficultyMultipliers.${level}.maintenance`, { min: 0 });
  }

  assertCapturePressureRows(config.capturePressure, 'capturePressure');
  assertObject(config.capturePressureDefault, 'capturePressureDefault');
  assertNumber(config.capturePressureDefault.graceMs, 'capturePressureDefault.graceMs', {
    integer: true,
    min: 1,
    max: SAFE_INT_MAX,
  });
  assertNumber(config.capturePressureDefault.regenMultiplier, 'capturePressureDefault.regenMultiplier', { min: 0 });
}

export function generateTs(config) {
  const lines = [];
  lines.push(GENERATED_HEADER);
  lines.push("import type { Difficulty, Direction } from './types.js';");
  lines.push('');
  lines.push(`export const TICK_RATE = ${toTsNumber(config.tickRate)};`);
  lines.push('export const TICK_MS = 1000 / TICK_RATE;');
  lines.push('');
  lines.push(`export const SECTOR_SIZE = ${toTsNumber(config.sectorSize)};`);
  lines.push(`export const DOTS_FOR_AWAKEN = ${toTsNumber(config.dotsForAwaken)};`);
  lines.push(`export const MAX_AWAKEN_STOCK = ${toTsNumber(config.maxAwakenStock)};`);
  lines.push(`export const POWER_DURATION_MS = ${toTsNumber(config.powerDurationMs)};`);
  lines.push(`export const AWAKEN_DURATION_MS = ${toTsNumber(config.awakenDurationMs)};`);
  lines.push(`export const RESCUE_TIMEOUT_MS = ${toTsNumber(config.rescueTimeoutMs)};`);
  lines.push(`export const POWER_PELLET_RESPAWN_MS = ${toTsNumber(config.powerPelletRespawnMs)};`);
  lines.push('');
  lines.push(`export const PLAYER_BASE_SPEED = ${toTsNumber(config.playerBaseSpeed)};`);
  lines.push(`export const PLAYER_CAPTURED_SPEED_MULTIPLIER = ${toTsNumber(config.playerCapturedSpeedMultiplier)};`);
  lines.push(`export const GHOST_BASE_SPEED = ${toTsNumber(config.ghostBaseSpeed)};`);
  lines.push('');
  lines.push(`export const POWER_AURA_RADIUS = ${toTsNumber(config.powerAuraRadius)};`);
  lines.push('');
  lines.push("export const DIRECTION_VECTORS: Record<Exclude<Direction, 'none'>, { x: number; y: number }> = {");
  lines.push("  up: { x: 0, y: -1 },");
  lines.push("  down: { x: 0, y: 1 },");
  lines.push("  left: { x: -1, y: 0 },");
  lines.push("  right: { x: 1, y: 0 },");
  lines.push('};');
  lines.push('');

  lines.push('export function getMapSideByPlayerCount(playerCount: number): number {');
  for (const row of config.mapSideByPlayers) {
    lines.push(`  if (playerCount <= ${row.maxPlayers}) {`);
    lines.push(`    return ${row.value};`);
    lines.push('  }');
  }
  lines.push(`  return ${config.mapSideDefault};`);
  lines.push('}');
  lines.push('');

  lines.push('export function getInitialGhostCount(playerCount: number): number {');
  for (const row of config.initialGhostCountByPlayers) {
    lines.push(`  if (playerCount <= ${row.maxPlayers}) {`);
    lines.push(`    return ${row.value};`);
    lines.push('  }');
  }
  lines.push(`  return ${config.initialGhostCountDefault};`);
  lines.push('}');
  lines.push('');

  lines.push('export function getTimeLimitMs(playerCount: number): number {');
  for (const row of config.timeLimitMsByPlayers) {
    lines.push(`  if (playerCount <= ${row.maxPlayers}) {`);
    lines.push(`    return ${row.value};`);
    lines.push('  }');
  }
  lines.push(`  return ${config.timeLimitMsDefault};`);
  lines.push('}');
  lines.push('');

  lines.push('export function getDifficultyMultiplier(difficulty: Difficulty): { ghostSpeed: number; maintenance: number } {');
  lines.push("  if (difficulty === 'casual') {");
  lines.push(`    return { ghostSpeed: ${toTsNumber(config.difficultyMultipliers.casual.ghostSpeed)}, maintenance: ${toTsNumber(config.difficultyMultipliers.casual.maintenance)} };`);
  lines.push('  }');
  lines.push("  if (difficulty === 'hard') {");
  lines.push(`    return { ghostSpeed: ${toTsNumber(config.difficultyMultipliers.hard.ghostSpeed)}, maintenance: ${toTsNumber(config.difficultyMultipliers.hard.maintenance)} };`);
  lines.push('  }');
  lines.push("  if (difficulty === 'nightmare') {");
  lines.push(`    return { ghostSpeed: ${toTsNumber(config.difficultyMultipliers.nightmare.ghostSpeed)}, maintenance: ${toTsNumber(config.difficultyMultipliers.nightmare.maintenance)} };`);
  lines.push('  }');
  lines.push(`  return { ghostSpeed: ${toTsNumber(config.difficultyMultipliers.normal.ghostSpeed)}, maintenance: ${toTsNumber(config.difficultyMultipliers.normal.maintenance)} };`);
  lines.push('}');
  lines.push('');

  lines.push('export function getCapturePressure(captureRatio: number): { graceMs: number; regenMultiplier: number } {');
  for (const row of config.capturePressure) {
    lines.push(`  if (captureRatio <= ${toTsNumber(row.maxCaptureRatio)}) {`);
    lines.push(`    return { graceMs: ${row.graceMs}, regenMultiplier: ${toTsNumber(row.regenMultiplier)} };`);
    lines.push('  }');
  }
  lines.push(`  return { graceMs: ${config.capturePressureDefault.graceMs}, regenMultiplier: ${toTsNumber(config.capturePressureDefault.regenMultiplier)} };`);
  lines.push('}');

  return `${lines.join('\n')}\n`;
}

export function generateRust(config) {
  const lines = [];
  lines.push(GENERATED_HEADER);
  lines.push('use crate::types::Difficulty;');
  lines.push('');
  lines.push(`pub const TICK_RATE: u32 = ${config.tickRate};`);
  lines.push('pub const TICK_MS: u64 = 1000 / TICK_RATE as u64;');
  lines.push('');
  lines.push(`pub const SECTOR_SIZE: i32 = ${config.sectorSize};`);
  lines.push(`pub const DOTS_FOR_AWAKEN: i32 = ${config.dotsForAwaken};`);
  lines.push(`pub const MAX_AWAKEN_STOCK: i32 = ${config.maxAwakenStock};`);
  lines.push(`pub const POWER_DURATION_MS: u64 = ${config.powerDurationMs};`);
  lines.push(`pub const AWAKEN_DURATION_MS: u64 = ${config.awakenDurationMs};`);
  lines.push(`pub const RESCUE_TIMEOUT_MS: u64 = ${config.rescueTimeoutMs};`);
  lines.push(`pub const POWER_PELLET_RESPAWN_MS: u64 = ${config.powerPelletRespawnMs};`);
  lines.push('');
  lines.push(`pub const PLAYER_BASE_SPEED: f32 = ${toRsFloat(config.playerBaseSpeed)};`);
  lines.push(`pub const PLAYER_CAPTURED_SPEED_MULTIPLIER: f32 = ${toRsFloat(config.playerCapturedSpeedMultiplier)};`);
  lines.push(`pub const GHOST_BASE_SPEED: f32 = ${toRsFloat(config.ghostBaseSpeed)};`);
  lines.push('');

  lines.push('pub fn get_map_side_by_player_count(player_count: usize) -> i32 {');
  for (const row of config.mapSideByPlayers) {
    lines.push(`    if player_count <= ${row.maxPlayers} {`);
    lines.push(`        return ${row.value};`);
    lines.push('    }');
  }
  lines.push(`    ${config.mapSideDefault}`);
  lines.push('}');
  lines.push('');

  lines.push('pub fn get_initial_ghost_count(player_count: usize) -> usize {');
  for (const row of config.initialGhostCountByPlayers) {
    lines.push(`    if player_count <= ${row.maxPlayers} {`);
    lines.push(`        return ${row.value};`);
    lines.push('    }');
  }
  lines.push(`    ${config.initialGhostCountDefault}`);
  lines.push('}');
  lines.push('');

  lines.push('pub fn get_time_limit_ms(player_count: usize) -> u64 {');
  for (const row of config.timeLimitMsByPlayers) {
    lines.push(`    if player_count <= ${row.maxPlayers} {`);
    lines.push(`        return ${row.value};`);
    lines.push('    }');
  }
  lines.push(`    ${config.timeLimitMsDefault}`);
  lines.push('}');
  lines.push('');

  lines.push('pub fn get_difficulty_multiplier(difficulty: Difficulty) -> (f32, f32) {');
  lines.push('    match difficulty {');
  lines.push(`        Difficulty::Casual => (${toRsFloat(config.difficultyMultipliers.casual.ghostSpeed)}, ${toRsFloat(config.difficultyMultipliers.casual.maintenance)}),`);
  lines.push(`        Difficulty::Normal => (${toRsFloat(config.difficultyMultipliers.normal.ghostSpeed)}, ${toRsFloat(config.difficultyMultipliers.normal.maintenance)}),`);
  lines.push(`        Difficulty::Hard => (${toRsFloat(config.difficultyMultipliers.hard.ghostSpeed)}, ${toRsFloat(config.difficultyMultipliers.hard.maintenance)}),`);
  lines.push(`        Difficulty::Nightmare => (${toRsFloat(config.difficultyMultipliers.nightmare.ghostSpeed)}, ${toRsFloat(config.difficultyMultipliers.nightmare.maintenance)}),`);
  lines.push('    }');
  lines.push('}');
  lines.push('');

  lines.push('pub fn get_capture_pressure(capture_ratio: f32) -> (u64, f32) {');
  for (const row of config.capturePressure) {
    lines.push(`    if capture_ratio <= ${toRsFloat(row.maxCaptureRatio)} {`);
    lines.push(`        return (${row.graceMs}, ${toRsFloat(row.regenMultiplier)});`);
    lines.push('    }');
  }
  lines.push(`    (${config.capturePressureDefault.graceMs}, ${toRsFloat(config.capturePressureDefault.regenMultiplier)})`);
  lines.push('}');

  return `${lines.join('\n')}\n`;
}

export async function loadConfig(configPath = defaultConfigPath) {
  const raw = await readFile(configPath, 'utf8');
  const parsed = JSON.parse(raw);
  validateConfig(parsed);
  return parsed;
}

export function buildOutputs(config) {
  validateConfig(config);
  return {
    ts: generateTs(config),
    rust: generateRust(config),
  };
}

export async function writeGeneratedFiles(outputs, paths = { tsPath: defaultTsPath, rsPath: defaultRsPath }) {
  await writeFile(paths.tsPath, outputs.ts, 'utf8');
  await writeFile(paths.rsPath, outputs.rust, 'utf8');
}

export async function verifyGeneratedFiles(outputs, paths = { tsPath: defaultTsPath, rsPath: defaultRsPath }) {
  const mismatches = [];
  const checks = [
    ['src/shared/constants.ts', paths.tsPath, outputs.ts],
    ['rust/server/src/constants.rs', paths.rsPath, outputs.rust],
  ];
  for (const [label, filePath, expected] of checks) {
    let actual = '';
    try {
      actual = await readFile(filePath, 'utf8');
    } catch (error) {
      if (error && typeof error === 'object' && 'code' in error && error.code === 'ENOENT') {
        mismatches.push(`${label} is missing`);
        continue;
      }
      throw error;
    }
    if (actual !== expected) {
      mismatches.push(`${label} is out of date`);
    }
  }
  if (mismatches.length > 0) {
    throw new Error(`${mismatches.join('\n')}\nRun: npm run generate:game-rules`);
  }
}

function parseArgs(argv) {
  const checkMode = argv.includes('--check');
  const unknown = argv.filter((arg) => arg !== '--check');
  if (unknown.length > 0) {
    throw new Error(`Unknown argument(s): ${unknown.join(', ')}`);
  }
  return { checkMode };
}

export async function runGenerator({ checkMode = false } = {}) {
  const config = await loadConfig(defaultConfigPath);
  const outputs = buildOutputs(config);
  if (checkMode) {
    await verifyGeneratedFiles(outputs, { tsPath: defaultTsPath, rsPath: defaultRsPath });
    console.log('Generated constants are up to date.');
    return;
  }
  await writeGeneratedFiles(outputs, { tsPath: defaultTsPath, rsPath: defaultRsPath });
  console.log('Generated src/shared/constants.ts and rust/server/src/constants.rs from config/game_rules.json');
}

const invokedPath = process.argv[1] ? path.resolve(process.argv[1]) : '';
if (invokedPath === fileURLToPath(import.meta.url)) {
  try {
    const { checkMode } = parseArgs(process.argv.slice(2));
    await runGenerator({ checkMode });
  } catch (error) {
    const message = error instanceof Error ? error.message : String(error);
    console.error(message);
    process.exit(1);
  }
}
